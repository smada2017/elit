\documentclass{article}

\include{common}

\title{Values and Variables}
\date{}

\begin{document}

\maketitle

\begin{center}
\includegraphics[height=2.3in]{value-uga-shirt.jpg}
\end{center}


\section{Models, Languages, and Machines}

Computing is

\begin{quote}
any purposeful activity that marries the representation of some dynamic domain with the representation of some dynamic machine that provides theoretical, empirical or practical understanding of that domain or that machine.
\footnote{Isbell, et. al., {\it (Re)Defining Computing Curricula by (Re)Defining Computing}, SIGCSE Bulletin, Volume 41, Number 4, December 2009}
\end{quote}

\begin{itemize}
\item Computing is fundamentally a modeling activity.
\item A {\it model} is a representation of some information, physical reality, or a virtual entity in a manner that can then be interpreted, manipulated, and transformed.
\item A {\it language} is a means of representation.
\begin{itemize}
  \item A language enables reasoning and manipulation of the model.
\end{itemize}
\item A computational {\it machine} allows us to execute our models.
\end{itemize}




\section{Languages and Computation}

Every powerful language has three mechanisms for  combining simple ideas to form more complex ideas:\footnote{\href{http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html}{SICP 1.1}}

\begin{itemize}
\item primitive expressions, which represent the simplest entities the language is concerned with,

\item means of combination, by which compound elements are built from simpler ones, and

\item means of abstraction, by which compound elements can be named and manipulated as units.
\end{itemize}

In this lecture we'll focus on primitive expressions and basic abstraction.




\section{A Model of Course Average}

\begin{lstlisting}[language=Java]
public class CourseAverage {

    public static void main(String[] args) {
        double homeworkAvg = 74.2;
        double examAvg = (81 + 91 + 93) / 3;
        double finalExam = 89;
        double courseAverage = (.2 * homeworkAvg) + (.6 * examAvg)
            + (.2 * finalExam);
        System.out.println("Course Average: " + courseAverage);
    }
}
\end{lstlisting}

\begin{itemize}
\item {\tt 74.2, 81, 93, 95, 89} are {\it values} (primitive expressions)
\item {\tt homeworkAverage, examAvg, finalExam} are {\it abstractions} which {\it name} values.
\item The value assigned to {\tt courseAverage} is computed by a {\tt combination} of primitive values.
\item Our {\it model} of course average is expressed in a {\it language} that allows us to reason about, manipulate, and {\it run} the model.
\end{itemize}





\section{Identifiers}


An identifier is a string of characters.  Identifiers are used as names for classes, methods, and variables
\begin{itemize}
\item Java identifiers can contain letters, digits, and the underscore symbol and may not start with a digit.
\item Java identifiers are case-sensitive:  {\tt this} is not the same as {\tt This}.
\item Identifiers used by the Java language compiler are called reserved words, or keywords.
\begin{itemize}
\item Identifiers used by Java, like {\tt class}, {\tt public}, {\tt if} and so on.
\item Identifiers that aren't currently used but are reserved, like {\tt goto} and {\tt const}
\item You can't use reserved keywords for your own identifiers.\\
Full list is here: \url{http://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html}
\end{itemize}

\end{itemize}





\section{Variable Declarations}


Variables are identifiers that name a value. A variable has:
\begin{itemize}
\item a type, and
\item a storage location for the variable's value.
\end{itemize}

Variables must be declared before they are used.  Here's a declaration:
\begin{lstlisting}[language=Java]
float twoThirds;
\end{lstlisting}
\begin{itemize}
\item {\tt float} is the variable's type
\item {\tt twoThirds} is the variable name
\end{itemize}
The value of {\tt twoThirds} after the declaration statement above depends on whether {\tt twoThirds} is an instance variable or a local variable.  More on that later.




\section{Assignment Statements}


{\tt =} is the assignment operator.
\begin{itemize}
\item The identifier on the left side of a {\tt =} must be a variable identifier (an lvalue)
\item The right side of the {\tt =} must be an expression
\begin{itemize}
\item An expression has a value;
\item {\tt 2 + 3} is an expression.  It has the value {\tt 5}.
\item A variable is also an expression.  It has whatever value it was last assigned.
\end{itemize}

\end{itemize}

\begin{lstlisting}[language=Java]
float twoThirds;
twoThirds = 2/3;
\end{lstlisting}
We usually combine declaration and assignment into an initialization statement:
\begin{lstlisting}[language=Java]
float twoThirds = 2/3;
\end{lstlisting}





\section{Type Compatibility}


Legal assignments:
\begin{lstlisting}[language=Java]
int x = 1;                    // int literal
float y = 3.14159f;           // float literal
double z = 3.1415;            // double literal
boolean thisSentence = false; // boolean literal
String goedel = "incomplete"; // String literal
\end{lstlisting}

Illegal assignments:
\begin{lstlisting}[language=Java]
int x = 1.0;              // 1.0 is a double value
float y = 3.14159;        // 3.14159 is a double value
boolean thisSentence = 1; // 1 is an int value
\end{lstlisting}


Core concepts:
\begin{itemize}
\item every value has a type
\item every variable has a type
\item assignment of values to variables must be type compatible at compile-time
\end{itemize}





\section{Syntax and Semantics}


\begin{itemize}
\item Syntax - the form to which your source code must conform
\item Semantics - the meaning of the code, i.e., what it does
\end{itemize}
Consider:
\begin{lstlisting}[language=Java]
public class Expressions {
    public static void main(String[] args) {
        float twoThirds = 2/3;
        System.out.println(twoThirds);
    }
}
\end{lstlisting}

\begin{itemize}
\item The code inside {\tt main} conforms to the Java syntax: a sequence of statements that each end with a semicolon.
\item The meaning of the program, its semantics, is that we initialize the variable {\tt twoThirds} with the value {\tt .667} and then print it out to the console (or so we think ...)
\end{itemize}

Compile and run \href{\code/basics/Expressions.java}{Expressions.java} and see what it prints.




\section{Type Conversion}


When we run {\tt Expressions.java} we get this:
\begin{lstlisting}[language=Java]
$ javac Expressions.java
$ java Expressions
0.0
\end{lstlisting}

What happened?

\begin{itemize}
\item {\tt twoThirds} is a {\tt float}, so it can hold fractional values.
\item But {\tt 2} and {\tt 3} are literal representations of {\tt int} values.
\item {\tt 2/3} performed integer division, resulting in a value of {\tt 0}.
\item Since a {\tt float} variable can hold integer values, Java performed an automatic conversion to {\tt float} upon assignment to {\tt twoThirds}, which ended up with the value {\tt 0.0}.
\end{itemize}




\section{Type Conversions}


The previous example showed an implicit widening conversion
\begin{itemize}
\item {\tt float} is {\it wider} than {\tt int} because all integers are also floating point values.
\item Java will perform widening conversions automatically because no precision is lost.
\item To perform a narrowing conversion, you must explicitly cast the value.
\end{itemize}

This won't compile because an {\tt int} can't hold a fractional value; converting may cause a loss of precision (note that we're using {\tt double} values by including a decimal part):
\begin{lstlisting}[language=Java]
int threeFourths = 3.0/4.0;
\end{lstlisting}

You have to cast the {\tt double} to an int:

\begin{lstlisting}[language=Java]
int threeFourths = (int) (3.0/4.0);
\end{lstlisting}

What happens if we leave off the parentheses around {\tt (3.0/4.0)}?





\section{Integral Primitive Types}



\begin{itemize}
\item  {\tt byte}: The byte data type is an 8-bit signed two's complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive).

\item {\tt short}: The short data type is a 16-bit signed two's complement integer. It has a minimum value of -32,768 and a maximum value of 32,767 (inclusive).

\item {\tt int}: The int data type is a 32-bit signed two's complement integer. It has a minimum value of -2,147,483,648 and a maximum value of 2,147,483,647 (inclusive). For integral values {\tt int} is generally the default choice.

\item {\tt long}: The long data type is a 64-bit signed two's complement integer. It has a minimum value of -9,223,372,036,854,775,808 and a maximum value of 9,223,372,036,854,775,807 (inclusive). Use this data type when you need a range of values wider than those provided by int.
\end{itemize}




\section{Floating Point Primitive Types}


\begin{itemize}
\item {\tt float}: The float data type is a single-precision 32-bit IEEE 754 floating point. This data type should never be used for precise values, such as currency. For that, you will need to use the java.math.BigDecimal class instead. Numbers and Strings covers BigDecimal and other useful classes provided by the Java platform.

\item {\tt double}: The double data type is a double-precision 64-bit IEEE 754 floating point. Its range of values is beyond the scope of this discussion, but is specified in the Floating-Point Types, Formats, and Values section of the Java Language Specification. For decimal values, {\tt double} is generally the default choice. As mentioned above, this data type should never be used for precise values, such as currency.
\end{itemize}




\section{{\tt boolean} and {\tt char}}


\begin{itemize}
\item {\tt boolean}: The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its "size" isn't something that's precisely defined.

\item {\tt char}: The char data type is a single 16-bit Unicode character. It has a minimum value of \verb@'\u0000'@ (or 0) and a maximum value of \verb@'\uffff'@ (or 65,535 inclusive).
\end{itemize}





\section{Shortcut Assignment Statements}


Like C and C++, Java allows shortcut assignments:
\begin{itemize}
\item A binary operation that updates the value of a variable:
\begin{lstlisting}[language=Java]
x += 2; // same as x = x + 2;
\end{lstlisting}
\item Pre- and post-increment and decrement:
\begin{lstlisting}[language=Java]
x++; // post-increment; same as x = x + 1;
x--; // pre-decrement; same as x = x - 1;
\end{lstlisting}

\end{itemize}

\begin{multicols}{2}

Pre-increment: variable incremented before used in expression
\begin{lstlisting}[language=Java]
int x = 1;
int y = ++x;
// x == 2, y == 2;
\end{lstlisting}

\columnbreak

Post-increment: variable incremented after used in expression
\begin{lstlisting}[language=Java]
int x = 1;
int y = x++;
// x == 2, y == 1;
\end{lstlisting}

\end{multicols}

What's the value of {\tt x} after {\tt x = x++}?




\section{Precedence and Associativity}


If an expression contains no parentheses, Java evaluates expressions according to \href{http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html}{precedence} in a three-step process:
\begin{enumerate}
\item Associate operands with operators, starting with highest-precedence operators.  This step effectively parenthesizes expression
\item Evaluate subexpressions in left to right order (possibly in multiple sweeps if deeply nested)
\item Evaluate outer ``top-level'' operation once all subexpressions have been evaluated
\end{enumerate}
The expression {\tt 6 + 7 * 2 - 12} is evaluated in the following steps:
\begin{lstlisting}[language=Java]
((6 + (7 * 2)) - 12) // Associate operands with operators
((6 + 14) - 12)      // Evaluate subexpressions ...
(20 - 12)
8
\end{lstlisting}





\section{Side-Effects in Expressions}

Beware of side-effects.  Consider the evaluation of\\{\tt ((result = (++n)) + (other = (2*(++n))))}\\ for {\tt n = 2}:
\begin{lstlisting}[language=Java]
((result = (++n)) + (other = (2*(++n))))
((result = 3) + (other = (2*(++n))))
(3 + (other = (2*(++n))))
(3 + (other = (2*4))) // Note that n was 3 from the first pre-increment
(3 + (other = 8))
(3 + 8)
11
\end{lstlisting}

\begin{itemize}
\item An assignment statement has the value that was assigned
\item Pre-increment ({\tt ++n}) means {\tt n} is incremented before it's used in the expression in which it appears
\item Three side-effects: result = 3, other = 8, and n = 4
\end{itemize}
Don't write code like this!




\section{{\tt String} Values}


A {\tt String} is a sequence of characters.
\begin{itemize}

\item {\tt String} literals are enclosed in double quotes
\begin{lstlisting}[language=Java]
"foo"
\end{lstlisting}

\item {\tt String} variables

\begin{lstlisting}[language=Java]
String foo = "foo";
\end{lstlisting}

\end{itemize}

Note that, unlike the other types we've seen, {\tt String} is capitalized.  {\tt String} is a class.





\section{{\tt String} Concatenation }


The {\tt +} operator is overloaded to mean concatenation for {\tt String} objects.

\begin{itemize}

\item Strings can be concatenated
\begin{lstlisting}[language=Java]
String bam = foo + bar + baz; // Now bam is "foobarbaz"
\end{lstlisting}

\item Primitive types can also be concatenated with {\tt Strings}.  The primitive is converted to a String
\begin{lstlisting}[language=Java]
String s = bam + 42; // s is "foobarbaz42"
String t = 42 + bam; // t is "42foobarbaz"
\end{lstlisting}

\end{itemize}

Note that {\tt +} is only overloaded for {\tt String}s.




\section{The {\tt String} Class}


{\tt String} acts like primitive thanks to syntactic sugar provided by the Java compiler, but it is defined as a class in the Java standard library

\begin{itemize}

\item See \href{http://docs.oracle.com/javase/8/docs/api/java/lang/String.html}{http://docs.oracle.com/javase/8/docs/api/java/lang/String.html} for details.

\item Methods on objects are invoked on the object using the {\tt .} operator
\begin{lstlisting}[language=Java]
String empty = "";
int len = empty.length(); // len is 0
\end{lstlisting}

\item Look up the methods {\tt length}, {\tt indexOf}, {\tt substring}, and {\tt compareTo}, and {\tt trim}

\item Because {\tt String}s are objects, beware of null references:
\begin{lstlisting}[language=Java]
String boom = null;
int aPosInBoom = boom.indexOf("a");
\end{lstlisting}

\end{itemize}

Play with \href{\code/basics/Strings.java}{Strings.java}

\section{Closing Thoughts}

Every powerful language has three mechanisms for  combining simple ideas to form more complex ideas:\footnote{\href{http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html}{SICP 1.1}}

\begin{itemize}
\item primitive expressions, which represent the simplest entities the language is concerned with,
\begin{itemize}
\item Values are the atoms of programs
\end{itemize}

\item means of combination, by which compound elements are built from simpler ones, and
\begin{itemize}
\item Programs combine and manipulate values
\end{itemize}

\item means of abstraction, by which compound elements can be named and manipulated as units.
\begin{itemize}
\item Variables are the simplest form of abstraction - naming values
\end{itemize}

\end{itemize}


\end{document}
